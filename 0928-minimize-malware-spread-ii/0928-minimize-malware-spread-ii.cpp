#define N 400
class Solution {
public:
    //dsu
    int root[N];
    int sz[N];
    void make(int node){
        root[node]=node;
        sz[node]=1;
    }
    int find(int node){
        if(root[node]==node) return node;
        return root[node]=find(root[node]);
    }
    void Union(int u,int v){
        u=find(u);
        v=find(v);
        if(u==v) return;
        if(sz[u]>sz[v]) swap(u,v);
        root[u]=v;
        sz[v]+=sz[u];
    }

    int minMalwareSpread(vector<vector<int>>& mat, vector<int>& initial) {
        int n=mat.size();
        set<int>s;
        for(auto i:initial) s.insert(i);
        vector<int>match;
        int mx=0;
        sort(initial.begin(),initial.end());
        int ans=*s.begin();
        // for every node in initial.....skip that node(infected one) and build dsu then find sum of all components size that does not contain any other initial node(or basically infected node)
        for(auto j:initial){
                for(int i=0;i<n;i++)  make(i);
                for(int i=0;i<n*n;i++){
                     if(i/n!=i%n && mat[i/n][i%n]==1){
                         if(i/n!=j && i%n!=j){
                              Union(i/n,i%n);
                         }
                     }
                }
            
                int temp=0;
                set<int>ini_par;
                for(int i:initial) if(i!=j) ini_par.insert(find(i));
                for(int i=0;i<n;i++){
                    if(root[i]==i){
                        cout<<i;
                        if(ini_par.find(i)!=ini_par.end()) continue;
                        else temp+=sz[i];
                    }
                }
            
                if(temp>mx){
                  mx=temp;
                  ans=j;
                }
        }
        return ans;
    }
};